snippet try
try {
	$1
} catch (e) {
	$2
};
endsnippet

snippet imp
import $1 from $2;
endsnippet


###########################################################################
#                            fp - ts																			#
###########################################################################

###################
# 		Import 			#
###################

# io-ts
snippet impio
import * as t from "io-ts";
endsnippet

# Option
snippet impo
import * as O from "fp-ts/lib/Option";
endsnippet

# Either
snippet impe
import * as E from "fp-ts/lib/Either";
endsnippet

# TaskEither
snippet impte
import * as TE from "fp-ts/lib/TaskEither";
endsnippet

# ReaderTaskEither
snippet imprte
import * as RTE from "fp-ts/lib/ReaderTaskEither";
endsnippet

# Array
snippet impa
import * as A from "fp-ts/lib/Array";
endsnippet

# NonEmptyString
snippet impne
import { NonEmptyString } from "io-ts-types/lib/NonEmptyString";
endsnippet

# UUID
snippet impuu
import { UUID } from "io-ts-types/lib/UUID";
endsnippet

# Pipe
snippet impp
import { pipe } from "fp-ts/lib/function";
endsnippet

# TaskEither
snippet tei
TaskEither<$1, $2>$0
endsnippet

# Either
snippet ei
Either<$1, $2> $0
endsnippet

# Option
snippet opt
Option<$1>
endsnippet

# new io-ts type
snippet iot
const $1C = t.type({
	$0
});
endsnippet

# new io-ts type with export
snippet iote
const $1C = t.type({
	$0
});

export type $1 = t.TypeOf<typeof $1C>;
endsnippet

# new io-ts array
snippet iota
const $1sC = t.array($1C);
endsnippet

# arrow function
snippet fnc
const $1 = ($2): $3 =>
	$0
endsnippet

# eslint disable
snippet esl
/* eslint-disable $0*/
endsnippet

# test
snippet tc
test("$1", async () => {
	$0
});
endsnippet

# describe
snippet des
describe("$1", () => {
	$0
});
endsnippet

# new type
snippet nt

export interface $1 extends Newtype<{ readonly $1: unique symbol}, $2> {};
export const iso$1 = iso<$1>();
$0
endsnippet

# new type

snippet tee
export type $1Error = {
  readonly error_type: "$2_error";
  readonly message: string;
};

endsnippet
